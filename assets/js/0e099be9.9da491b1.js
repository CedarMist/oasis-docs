"use strict";(self.webpackChunkdocs_oasis_dev=self.webpackChunkdocs_oasis_dev||[]).push([[7861],{3905:(o,e,t)=>{t.d(e,{Zo:()=>c,kt:()=>f});var n=t(7294);function a(o,e,t){return e in o?Object.defineProperty(o,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):o[e]=t,o}function r(o,e){var t=Object.keys(o);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(o);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(o,e).enumerable}))),t.push.apply(t,n)}return t}function s(o){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?r(Object(t),!0).forEach((function(e){a(o,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(o,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(e){Object.defineProperty(o,e,Object.getOwnPropertyDescriptor(t,e))}))}return o}function p(o,e){if(null==o)return{};var t,n,a=function(o,e){if(null==o)return{};var t,n,a={},r=Object.keys(o);for(n=0;n<r.length;n++)t=r[n],e.indexOf(t)>=0||(a[t]=o[t]);return a}(o,e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(o);for(n=0;n<r.length;n++)t=r[n],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(o,t)&&(a[t]=o[t])}return a}var l=n.createContext({}),i=function(o){var e=n.useContext(l),t=e;return o&&(t="function"==typeof o?o(e):s(s({},e),o)),t},c=function(o){var e=i(o.components);return n.createElement(l.Provider,{value:e},o.children)},d="mdxType",u={inlineCode:"code",wrapper:function(o){var e=o.children;return n.createElement(n.Fragment,{},e)}},m=n.forwardRef((function(o,e){var t=o.components,a=o.mdxType,r=o.originalType,l=o.parentName,c=p(o,["components","mdxType","originalType","parentName"]),d=i(t),m=a,f=d["".concat(l,".").concat(m)]||d[m]||u[m]||r;return t?n.createElement(f,s(s({ref:e},c),{},{components:t})):n.createElement(f,s({ref:e},c))}));function f(o,e){var t=arguments,a=e&&e.mdxType;if("string"==typeof o||a){var r=t.length,s=new Array(r);s[0]=m;var p={};for(var l in e)hasOwnProperty.call(e,l)&&(p[l]=e[l]);p.originalType=o,p[d]="string"==typeof o?o:a,s[1]=p;for(var i=2;i<r;i++)s[i]=t[i];return n.createElement.apply(null,s)}return n.createElement.apply(null,t)}m.displayName="MDXCreateElement"},1815:(o,e,t)=>{t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>s,default:()=>u,frontMatter:()=>r,metadata:()=>p,toc:()=>i});var n=t(7462),a=(t(7294),t(3905));const r={},s="DAO Contract",p={unversionedId:"dapp/opl/host",id:"dapp/opl/host",title:"DAO Contract",description:"Let's start with a DAOV1.sol smart contract that describes a basic DAO with a",source:"@site/docs/dapp/opl/host.md",sourceDirName:"dapp/opl",slug:"/dapp/opl/host",permalink:"/dapp/opl/host",draft:!1,editUrl:"https://github.com/oasisprotocol/docs/edit/main/docs/dapp/opl/host.md",tags:[],version:"current",lastUpdatedAt:1687256264,formattedLastUpdatedAt:"Jun 20, 2023",frontMatter:{},sidebar:"developers",previous:{title:"Setup",permalink:"/dapp/opl/setup"},next:{title:"Ballot Contract",permalink:"/dapp/opl/enclave"}},l={},i=[{value:"OPL Differences",id:"opl-differences",level:3},{value:"Constructor",id:"constructor",level:4},{value:"Endpoints",id:"endpoints",level:4}],c={toc:i},d="wrapper";function u(o){let{components:e,...t}=o;return(0,a.kt)(d,(0,n.Z)({},c,t,{components:e,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"dao-contract"},"DAO Contract"),(0,a.kt)("p",null,"Let's start with a ",(0,a.kt)("inlineCode",{parentName:"p"},"DAOV1.sol")," smart contract that describes a basic DAO with a\nmapping of proposals. Place it inside your ",(0,a.kt)("inlineCode",{parentName:"p"},"contracts/")," directory. We will\ndeploy this contract to your home network such as BNB or Polygon."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},'// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {EnumerableSet} from "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";\n\ntype ProposalId is bytes32;\n\nstruct ProposalParams {\n    string ipfsHash;\n    uint16 numChoices;\n    bool publishVotes;\n}\n\ncontract DAOV1 {\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    error AlreadyExists();\n    error NoChoices();\n    error TooManyChoices();\n\n    event ProposalClosed(ProposalId id, uint256 topChoice);\n\n    struct Proposal {\n        bool active;\n        uint16 topChoice;\n        ProposalParams params;\n    }\n\n    struct ProposalWithId {\n        ProposalId id;\n        Proposal proposal;\n    }\n\n    mapping(ProposalId => Proposal) public proposals;\n    EnumerableSet.Bytes32Set private activeProposals;\n    ProposalId[] private pastProposals;\n\n    constructor() {}\n\n    function createProposal(ProposalParams calldata _params) external payable returns (ProposalId) {\n        bytes32 proposalHash = keccak256(abi.encode(msg.sender, _params));\n        ProposalId proposalId = ProposalId.wrap(proposalHash);\n        if (_params.numChoices == 0) revert NoChoices();\n        if (_params.numChoices > type(uint16).max) revert TooManyChoices();\n        if (proposals[proposalId].active) revert AlreadyExists();\n        Proposal storage proposal = proposals[proposalId];\n        proposal.params = _params;\n        proposal.active = true;\n        activeProposals.add(proposalHash);\n        return proposalId;\n    }\n\n    function getActiveProposals(\n        uint256 _offset,\n        uint256 _count\n    ) external view returns (ProposalWithId[] memory _proposals) {\n        if (_offset + _count > activeProposals.length()) {\n            _count = activeProposals.length() - _offset;\n        }\n        _proposals = new ProposalWithId[](_count);\n        for (uint256 i; i < _count; ++i) {\n            ProposalId id = ProposalId.wrap(activeProposals.at(_offset + i));\n            _proposals[i] = ProposalWithId({id: id, proposal: proposals[id]});\n        }\n    }\n\n    function getPastProposals(\n        uint256 _offset,\n        uint256 _count\n    ) external view returns (ProposalWithId[] memory _proposals) {\n        if (_offset + _count > pastProposals.length) {\n            _count = pastProposals.length - _offset;\n        }\n        _proposals = new ProposalWithId[](_count);\n        for (uint256 i; i < _count; ++i) {\n            ProposalId id = pastProposals[_offset + i];\n            _proposals[i] = ProposalWithId({id: id, proposal: proposals[id]});\n        }\n    }\n}\n')),(0,a.kt)("p",null,"Instead of storing complete ballot proposals on the network, we will use\n",(0,a.kt)("a",{parentName:"p",href:"https://ipfs.tech"},"IPFS"),". Our smart contract will refer to a pinned ",(0,a.kt)("a",{parentName:"p",href:"https://docs.ipfs.tech/concepts/lifecycle/#_1-content-addressable-representation"},"IPFS file"),"\nby its ",(0,a.kt)("a",{parentName:"p",href:"https://docs.ipfs.tech/concepts/hashing/"},"hash"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"struct ProposalParams {\n    string ipfsHash;\n    uint16 numChoices;\n    bool publishVotes;\n}\n")),(0,a.kt)("p",null,"Our very simple DAO contract creates proposals and manages them, allowing\nboth active (",(0,a.kt)("inlineCode",{parentName:"p"},"getActiveProposals"),") and past proposals (",(0,a.kt)("inlineCode",{parentName:"p"},"getPastProposals"),") to\nbe queried externally."),(0,a.kt)("h3",{id:"opl-differences"},"OPL Differences"),(0,a.kt)("p",null,"A ",(0,a.kt)("em",{parentName:"p"},"host contract")," refers to a smart contract on a home network such as BNB or\nPolygon. We will extend the ",(0,a.kt)("inlineCode",{parentName:"p"},"Host")," contract provided by OPL and add our own\nimplementation of event handling to process cross-chain messages. Let's make\nthe following changes to ",(0,a.kt)("inlineCode",{parentName:"p"},"DAOV1.sol"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-diff"},'diff --git a/backend/contracts/DAOV1.sol b/backend/contracts/DAOV1.sol\nindex 21ea93e..827d80a 100644\n--- a/backend/contracts/DAOV1.sol\n+++ b/backend/contracts/DAOV1.sol\n@@ -1,6 +1,7 @@\n // SPDX-License-Identifier: MIT\n pragma solidity ^0.8.0;\n \n+import {Host, Result} from "@oasisprotocol/sapphire-contracts/contracts/OPL.sol";\n import {EnumerableSet} from "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";\n \n type ProposalId is bytes32;\n@@ -11,7 +12,7 @@ struct ProposalParams {\n     bool publishVotes;\n }\n\n-contract DAOV1 {\n+contract DAOV1 is Host {\n     using EnumerableSet for EnumerableSet.Bytes32Set;\n \n     error AlreadyExists();\n@@ -35,7 +36,9 @@ contract DAOV1 {\n     EnumerableSet.Bytes32Set private activeProposals;\n     ProposalId[] private pastProposals;\n \n-    constructor() {}\n+    constructor(address _ballotBox) Host(_ballotBox) {\n+        registerEndpoint("ballotClosed", _oplBallotClosed);\n+    }\n \n     function createProposal(ProposalParams calldata _params) external payable returns (ProposalId) {\n         bytes32 proposalHash = keccak256(abi.encode(msg.sender, _params));\n@@ -47,6 +50,7 @@ contract DAOV1 {\n         proposal.params = _params;\n         proposal.active = true;\n         activeProposals.add(proposalHash);\n+        postMessage("createBallot", abi.encode(proposalId, _params));\n         return proposalId;\n     }\n \n@@ -77,4 +81,14 @@ contract DAOV1 {\n             _proposals[i] = ProposalWithId({id: id, proposal: proposals[id]});\n         }\n     }\n+\n+    function _oplBallotClosed(bytes calldata _args) internal returns (Result) {\n+        (ProposalId proposalId, uint16 topChoice) = abi.decode(_args, (ProposalId, uint16));\n+        proposals[proposalId].topChoice = topChoice;\n+        proposals[proposalId].active = false;\n+        activeProposals.remove(ProposalId.unwrap(proposalId));\n+        pastProposals.push(proposalId);\n+        emit ProposalClosed(proposalId, topChoice);\n+        return Result.Success;\n+    }\n }\n')),(0,a.kt)("h4",{id:"constructor"},"Constructor"),(0,a.kt)("p",null,"We provide the address of the confidential (also known as ",(0,a.kt)("em",{parentName:"p"},"enclave"),") smart\ncontract deployed on the Oasis Sapphire as a constructor parameter to the\n",(0,a.kt)("em",{parentName:"p"},"host")," smart contract."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},'    constructor(address _ballotBox) Host(_ballotBox) {\n        registerEndpoint("ballotClosed", _oplBallotClosed);\n    }\n')),(0,a.kt)("h4",{id:"endpoints"},"Endpoints"),(0,a.kt)("p",null,"Events in Solidity are non-confidential and do not allow cross-chain\ncommunication. For this reason, OPL uses ",(0,a.kt)("em",{parentName:"p"},"endpoints")," for passing messages\ncross-chain. Endpoints are effectively callbacks which listen to messages\nfrom the Enclaved smart contract. The function below will listen to such a\nmessage and close the proposal."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"    function _oplBallotClosed(bytes calldata _args) internal returns (Result) {\n        (ProposalId proposalId, uint16 topChoice) = abi.decode(_args, (ProposalId, uint16));\n        proposals[proposalId].topChoice = topChoice;\n        proposals[proposalId].active = false;\n        activeProposals.remove(ProposalId.unwrap(proposalId));\n        pastProposals.push(proposalId);\n        emit ProposalClosed(proposalId, topChoice);\n        return Result.Success;\n    }\n")))}u.isMDXComponent=!0}}]);